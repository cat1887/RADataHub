<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK Hex Map</title>
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            font-family: Arial, sans-serif;
            position: relative;
            overflow-x: hidden;
        }

        .map-container {
            position: -webkit-sticky;
            /* For Safari */
            position: sticky;
            top: 15vh;
            height: 70vh;
            width: 100%;
            z-index: 1;
        }

        .map {
            width: 100%;
            height: 100%;
            margin-top: 100px;
        }

        .info {
            padding-top: 20px;
            width: 30vw;
            padding-left: 700px;
            z-index: 2;
            position: relative;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.8);
            margin-bottom: 200px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        button {
            position: fixed;
            bottom: 50px;
            right: 50px;
            width: 150px;
            height: 50px;

            z-index: 2;
        }

        svg {
        }
    </style>
</head>

<body>
    <button onclick="drawHexBarGraph('employment_rate_quintile')"> Transition to Employment Rate chart </button>
    <div id="container">
        <div class="map-container">
            <svg class="map"></svg>
        </div>
        <div class="info">
            <!-- <div class="info-box">
                <h2>Information 1</h2>
                <p> Lorem ipsum, dolor sit amet consectetur adipisicing elit. Laudantium, distinctio aut molestias, consequatur vitae.</p>
            </div>
            <div class="info-box">
                <h2>Information 2</h2>
                <p>This is the second info box containing additional information.</p>
            </div>
            <div class="info-box">
                <h2>Information 1</h2>
                <p>This is the first info box containing information about the constituencies.</p>
            </div>
            <div class="info-box">
                <h2>Information 2</h2>
                <p>This is the second info box containing additional information.</p>
            </div>

            <div class="info-box">
                <h2>Information 1</h2>
                <p>This is the first info box containing information about the constituencies.</p>
            </div>
            <div class="info-box">
                <h2>Information 2</h2>
                <p>This is the second info box containing additional information.</p>
            </div>

            <div class="info-box">
                <h2>Information 1</h2>
                <p>This is the first info box containing information about the constituencies.</p>
            </div>
            <div class="info-box">
                <h2>Information 2</h2>
                <p>This is the second info box containing additional information.</p>
            </div>
 -->
            <!-- Add more info boxes as needed -->
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = document.querySelector('.map').clientWidth;
        const height = document.querySelector('.map').clientHeight;

        const svg = d3.select('.map')
            .attr('width', width)
            .attr('height', height);

        const projection = d3.geoIdentity().reflectY(true).fitSize([width, height], { type: 'FeatureCollection', features: [] });
        const path = d3.geoPath().projection(projection);

        // Define a color scale for the major parties
        const colorScale = d3.scaleOrdinal()
            .domain(['Lab', 'SNP', 'Con'])
            .range(['#d50000', '#ffab00', '#2962ff']);

        // Load the CSV file
        d3.csv('indicators.csv').then(csvData => {
            // make the csv data available globally
            window.csvData = csvData;
            const csvMap = new Map();
            csvData.forEach(d => {
                csvMap.set(d.GSScode, d.winner_2019);
            });

            // Load the GeoJSON file
            d3.json('hexes.geojson').then(geojson => {
                projection.fitSize([width, height], geojson);

                // add each col of the csv data to the properties of the geojson by matching the GSS code
                csvData.forEach(d => {
                    const feature = geojson.features.find(f => f.properties.GSScode === d.GSScode);
                    if (feature) {
                        Object.keys(d).forEach(key => {
                            feature.properties[key] = d[key];
                        });
                    }
                });


                svg.selectAll('.hex')
                    .data(geojson.features)
                    .enter().append('path')
                    .attr('d', path)
                    .attr("class", "hex")
                    .attr('stroke', '#ccc')
                    .attr('fill', d => {
                        const winner = csvMap.get(d.properties.GSScode);
                        return winner ? colorScale(winner) : '#ddd'; // Default to light grey if no match
                    });

            });
        });

        function getTranslateNeededForXY(element, x, y, rotation = 60) {

            // what's the current position - according to its bounding box
            const bbox = element.node().getBBox();
            const currentX = bbox.x + bbox.width / 2;
            const currentY = bbox.y + bbox.height / 2;

            // what's the difference between the current position and the desired position
            const dx = x - currentX;
            const dy = y - currentY;

            // return the correct translation with them rotated around their center
            return `translate(${dx}, ${dy})`;
        }

        function rearrangeHexes() {
            // If a hex's properties.fid is even move it to 200, 200 + a random number between 0 and 100
            // If a hex's properties.fid is odd move it to 400, 400 + a random number between 0 and 100

            svg.selectAll('.hex')
                .transition()
                .duration(1000)
                .attr('transform', function (d) {
                    const selection = d3.select(this);
                    const neededTranslate = getTranslateNeededForXY(
                        selection,
                        d.properties.fid % 2 === 0 ? 200 + Math.random() * 100 : 400 + Math.random() * 100,
                        d.properties.fid % 2 === 0 ? 200 + Math.random() * 100 : 400 + Math.random() * 100
                    );
                    return neededTranslate;
                });
        }

        axisSettings = {
            'employment_rate_quintile': {
                "title": "Employment Rate (16-64)",
                "rangeOrder": ["Lowest Quintile", "Second Quintile", "Third Quintile", "Fourth Quintile", "Highest Quintile"],
            },
            'rqf4_rate_quintile' : {
                "title": "Graduates (RQF4+, %)",
                "rangeOrder": ["Lowest Quintile", "Second Quintile", "Third Quintile", "Fourth Quintile", "Highest Quintile"],
            },
        }

        function drawHexBarGraph(yAttr) {
            const plotAreaPadding = {
                'left': 150,
                'right': 50,
                'top': 50,
                'bottom': 50
            };

            yAttr = yAttr || 'employment_rate_quintile';

            // get the unique values of the y attribute
            const yValues = [...new Set(csvData.map(d => d[yAttr]))];

            console.log(`yValues: ${yValues}`);

            // y axis: the quintiles (nominal)
            const y = d3.scaleBand()
                .domain(axisSettings[yAttr].rangeOrder)
                .range([height - plotAreaPadding.bottom, plotAreaPadding.top])
                .padding(0.1);

            // x axis - [0, the number of hexes in the largest quintile]
            const maxHexCount = d3.max(yValues, d => csvData.filter(e => e[yAttr] === d).length);
            const x = d3.scaleLinear()
                .domain([0, Math.ceil(maxHexCount / 30) * 30])
                .range([plotAreaPadding.left, width - plotAreaPadding.right]);

            const hexWidth = d3.select('path').node().getBBox().width;
            const hexHeight = d3.select('path').node().getBBox().height;

            // Create a counter for each y value
            const counters = {};
            yValues.forEach(value => {
                counters[value] = 0;
            });

            // Add the x axis
            const xAxis = d3.axisBottom(x)
                .ticks(0)
                .tickSize(0);

            // Add the y axis
            const yAxis = d3.axisLeft(y)
                .ticks(0)
                .tickSize(0);

            const axisG = svg.append('g')

            axisG.style("opacity", 0)
                .transition()
                .duration(2000)
                .style("opacity", 1);


            axisG.append('g')
                .attr('class', 'y-axis')
                .attr('transform', `translate(${plotAreaPadding.left - 0.5 * hexWidth}, 0)`)
                .call(yAxis)
                .append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('x', 285)
                .attr('y', 30)
                .attr('fill', 'black')
                .attr('text-anchor', 'left')
                .attr('font-weight', 'bold')
                .attr('font-size', '24px')
                .text(axisSettings[yAttr].title);

            // Style the axis lines to be thin and gray
            axisG.selectAll('.x-axis path, .y-axis path')
                .attr('stroke', 'gray')
                .attr('stroke-width', 1);

            // Adjust the y-axis labels to be centered
            axisG.selectAll('.y-axis text')
                .attr('transform', function (d) {
                    const yValue = d;
                    const count = csvData.filter(e => e[yAttr] === yValue).length;
                    const rowIndex = Math.floor(count / 60); // Number of full rows
                    const midpoint = (rowIndex * hexHeight) / 2;
                    return `translate(0, ${-midpoint})`;
                });


            // Rearrange the hexes to the target x and y positions
            svg.selectAll('.hex')
            .attr("opacity", function (d) {
                    // if the property is null or undefined return 0
                    return d.properties[yAttr] ? 1 : 0;
                })
                .transition()
                .duration(2000)
                .attr('transform', function (d) {
                    const selection = d3.select(this);
                    const yValue = d.properties[yAttr];
                    const index = counters[yValue]++;
                    const rowIndex = Math.floor(index / 30);
                    const colIndex = index % 30;
                    let xPosition = plotAreaPadding.left + colIndex * hexWidth * 1.5; // Increment by hex width with left padding
                    let yPosition = y(yValue) + rowIndex * hexHeight + rowIndex*-0.5*hexHeight; // Increment by hex height with top padding

                    // Accumulate offsets for every other row within each y group
                    if (rowIndex % 2 === 1) {
                        xPosition +=  hexWidth * 0.75 ;
                    }

                    //yPosition += rowIndexYPositionOffsets[rowIndex];

                    const neededTranslate = getTranslateNeededForXY(
                        selection,
                        xPosition,
                        yPosition
                    );
                    return neededTranslate;
                });
        }

    </script>
</body>

</html>